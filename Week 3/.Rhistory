print(paste("Total Return:", as.character(total_ret)))
print(paste("Average Daily Return:", as.character(daily_ret)))
print(paste("Sharpe Ratio:", as.character(sharpe_ratio)))
print(paste("Maximum Drawdown:", as.character(max_drawdown)))
# Draw performance chart (hour-level)
charts.PerformanceSummary(R=roc_hour,
main="Peformance Summary")
# begin to test your strategy minute by minute
for(time in time_list){
# 1. initialization
if(time == time_list[[1]]){
cash_balance = initial_cash
total_balance = initial_cash
revenue = 0
margin_balance = 0
average_price_old = rowMeans(data_format2[[time]][1:4])
position_old = rep(0, nrow(info))
position_new = rep(0, nrow(info))
details = data.frame()
stop_signal = FALSE
}
# 2. calculate position & cash/margin/total balance & transaction cost etc.
position_change = position_new - position_old
average_price = rowMeans(data_format2[[time]][1:4])
transaction_cost = sum(abs(position_change)*transaction*average_price*info$unit_per_lot)
margin_change = abs(position_new)*average_price*info$margin_rate*info$unit_per_lot - abs(position_old)*average_price_old*info$margin_rate*info$unit_per_lot
margin_balance = margin_balance + sum(margin_change)
cash_balance = cash_balance - sum(margin_change) - transaction_cost
revenue = sum(position_old*(average_price-average_price_old)*info$unit_per_lot)
total_balance = total_balance + revenue - transaction_cost
details = rbind(details, c(position_new, cash_balance, margin_balance, revenue, total_balance, transaction_cost))
position_old = position_new
average_price_old = average_price
# 3. check special cases
# if cash balance is less than lower limit, clear all futures at next minute and stop strategy (i.e. switch stop_signal to TRUE)
if(cash_balance < cash_balance_lower_limit){
position_new = rep(0, nrow(info))
stop_signal = TRUE
print(paste("Current cash balance is lower than:", as.character(cash_balance_lower_limit)))
print("Your strategy is forced to stop.")
}
# when stop_signal is TRUE, stop the strategy part and keep the current balance (i.e., all cash)
if(stop_signal)
next
# 4. update position for NEXT minute using students' strategy function
output = strategy(time = time,
data = data_format2[[time]],
info = info,
initial_cash = initial_cash,
transaction = transaction,
cash_balance = cash_balance,
margin_balance = margin_balance,
total_balance = total_balance,
position_current = position_new,
memory = memory)
position_new = output[['position']]
memory = output[['memory']]
print(time)
}
colnames(details) = c(as.character(info$code), "cash.balance", "margin.balance", "revenue", "total.balance", "transaction.cost")
rownames(details) = time_list
# show minute-level details about your strategy, including:
# 1. positions of all 13 futures (the first 13 columns)
# 2. cash/margin/total balance
# 3. revenue (profit or loss) at each minute
# 4. transaction cost at each minute
View(details)
# calculate summary statistics (Sharpe ratio, total return, average daily return and maximum dropdown)
balance_xts = xts(x=details$total.balance, order.by=as.POSIXct(time_list))
roc_min = ROC(balance_xts, n = 1, type = "discrete")[2:length(time_list)]
roc_daily = period.apply(roc_min, endpoints(roc_min, "days"), function(x) prod(1+x)-1)
roc_hour = period.apply(roc_min, seq(0, length(time_list)-1, 60), function(x) prod(1+x)-1)
total_ret = prod(1+roc_min)-1
sharpe_ratio = SharpeRatio.annualized(roc_daily)
daily_ret = mean(roc_daily)
max_drawdown = min(DrawdownPeak(roc_hour))
print(paste("Total Return:", as.character(total_ret)))
print(paste("Average Daily Return:", as.character(daily_ret)))
print(paste("Sharpe Ratio:", as.character(sharpe_ratio)))
print(paste("Maximum Drawdown:", as.character(max_drawdown)))
# Draw performance chart (hour-level)
charts.PerformanceSummary(R=roc_hour,
main="Peformance Summary")
strategy = function(time, data, info, initial_cash, transaction, cash_balance, margin_balance, total_balance, position_current, memory=list()){
# Load variables from memory
counter = memory[["counter"]]
long_counter = memory[["long_counter"]]
short_counter = memory[["short_counter"]]
data_list = memory[["data_list"]]
bar = memory[["bar"]]
bar_prev = memory[["bar_prev"]]
long_check_table = memory[["long_check_table"]]
short_check_table = memory[["short_check_table"]]
# Update counter
#counter shows the number of minutes passed
counter = counter + 1
#print(counter)
# Generate OHLC data for every 15 minutes
if(counter%%bar_length == 0){
#print(bar_length)
# save minute data to data_list
data_list[[bar_length]] = data
bar = generate_bar(data_list, counter)
if(!is.null(bar_prev)){
# check patterns for a single bar
long_check = long_signal(data = bar, data_prev = bar_prev, asset = asset)
long_check_table = rbind(long_check_table, long_check)
short_check = short_signal(data = bar, data_prev = bar_prev, asset = asset)
short_check_table = rbind(short_check_table, short_check)
bar_num = counter/bar_length
if(bar_num > 3){
# When there is a three white soider signal, long 10 lots of asset at next minute unless the current cash balance is less than 3,000,000
# if (last_element(long_check_table["is_long_signal"]) == TRUE) && cache_long == 3
if (last_element(long_check_table["is_long_signal"]) == TRUE)  {
print("Long counter")
long_counter = long_counter + 1
if ((cash_balance > my_cash_balance_lower_limit) && (long_counter == 3)) {
position_new[asset] = position_current[asset] + 20
long_counter = 0
#print("Long balance")
#print(position_current)
#print(position_new)
#print(position_old)
}
}
# short signal
# When there is a three black craw signal, short 10 lots of asset at next minute unless the current cash balance is less than 3,000,000
if (last_element(short_check_table["is_short_signal"]) == TRUE) {
print("Short counter")
short_counter = short_counter + 1
print(short_counter)
if((cash_balance > my_cash_balance_lower_limit) && (short_counter == 3)) {
position_new[asset] = position_current[asset] - 10
short_counter = 0
#print("Short balance")
#print(position_current)
#print(position_new)
#print(position_old)
}
}
}
}
bar_prev = bar
} else {
# save minute data to data_list
data_list[[counter%%bar_length]] = data
}
# Update memory
memory[["counter"]] = counter
memory[["data_list"]] = data_list
memory[["bar"]] = bar
memory[["bar_prev"]] = bar_prev
memory[["long_check_table"]] = long_check_table
memory[["short_check_table"]] = short_check_table
memory[["long_counter"]] = long_counter
memory[["short_counter"]] = short_counter
return(list(position=position_new, memory=memory))
#End of the function
}
# begin to test your strategy minute by minute
for(time in time_list){
# 1. initialization
if(time == time_list[[1]]){
cash_balance = initial_cash
total_balance = initial_cash
revenue = 0
margin_balance = 0
average_price_old = rowMeans(data_format2[[time]][1:4])
position_old = rep(0, nrow(info))
position_new = rep(0, nrow(info))
details = data.frame()
stop_signal = FALSE
}
# 2. calculate position & cash/margin/total balance & transaction cost etc.
position_change = position_new - position_old
average_price = rowMeans(data_format2[[time]][1:4])
transaction_cost = sum(abs(position_change)*transaction*average_price*info$unit_per_lot)
margin_change = abs(position_new)*average_price*info$margin_rate*info$unit_per_lot - abs(position_old)*average_price_old*info$margin_rate*info$unit_per_lot
margin_balance = margin_balance + sum(margin_change)
cash_balance = cash_balance - sum(margin_change) - transaction_cost
revenue = sum(position_old*(average_price-average_price_old)*info$unit_per_lot)
total_balance = total_balance + revenue - transaction_cost
details = rbind(details, c(position_new, cash_balance, margin_balance, revenue, total_balance, transaction_cost))
position_old = position_new
average_price_old = average_price
# 3. check special cases
# if cash balance is less than lower limit, clear all futures at next minute and stop strategy (i.e. switch stop_signal to TRUE)
if(cash_balance < cash_balance_lower_limit){
position_new = rep(0, nrow(info))
stop_signal = TRUE
print(paste("Current cash balance is lower than:", as.character(cash_balance_lower_limit)))
print("Your strategy is forced to stop.")
}
# when stop_signal is TRUE, stop the strategy part and keep the current balance (i.e., all cash)
if(stop_signal)
next
# 4. update position for NEXT minute using students' strategy function
output = strategy(time = time,
data = data_format2[[time]],
info = info,
initial_cash = initial_cash,
transaction = transaction,
cash_balance = cash_balance,
margin_balance = margin_balance,
total_balance = total_balance,
position_current = position_new,
memory = memory)
position_new = output[['position']]
memory = output[['memory']]
print(time)
}
colnames(details) = c(as.character(info$code), "cash.balance", "margin.balance", "revenue", "total.balance", "transaction.cost")
rownames(details) = time_list
# show minute-level details about your strategy, including:
# 1. positions of all 13 futures (the first 13 columns)
# 2. cash/margin/total balance
# 3. revenue (profit or loss) at each minute
# 4. transaction cost at each minute
View(details)
# calculate summary statistics (Sharpe ratio, total return, average daily return and maximum dropdown)
balance_xts = xts(x=details$total.balance, order.by=as.POSIXct(time_list))
roc_min = ROC(balance_xts, n = 1, type = "discrete")[2:length(time_list)]
roc_daily = period.apply(roc_min, endpoints(roc_min, "days"), function(x) prod(1+x)-1)
roc_hour = period.apply(roc_min, seq(0, length(time_list)-1, 60), function(x) prod(1+x)-1)
total_ret = prod(1+roc_min)-1
sharpe_ratio = SharpeRatio.annualized(roc_daily)
daily_ret = mean(roc_daily)
max_drawdown = min(DrawdownPeak(roc_hour))
print(paste("Total Return:", as.character(total_ret)))
print(paste("Average Daily Return:", as.character(daily_ret)))
print(paste("Sharpe Ratio:", as.character(sharpe_ratio)))
print(paste("Maximum Drawdown:", as.character(max_drawdown)))
# Draw performance chart (hour-level)
charts.PerformanceSummary(R=roc_hour,
main="Peformance Summary")
n <- 13
low_df <- fit_arima_model(return = "low")
high_df <- fit_arima_model()
generate_bar = function(data_list, counter){
open = data_list[[1]][, "open"]
bar_len = length(data_list)
#Create rollmean
df_close <- data.frame(matrix(ncol = bar_len, nrow = nrow(data_list[[1]])))
rownames(df_close) <- row.names(data_list[[1]])
for (i in 1:length(data_list)) {
df_close[i] = data_list[[i]][, "close"]
}
t_close = t(df_close)
rm <- rollmeanr((t_close),3,fill=NA)
close_roll_mean = rm[bar_len,]
close = data_list[[length(data_list)]][, "close"]
high_mat = do.call(rbind, lapply(data_list, FUN = function(x) x[, "high"]))
high = apply(high_mat, 2, max)
low_mat = do.call(rbind, lapply(data_list, FUN = function(x) x[, "low"]))
low = apply(high_mat, 2, min)
roll_mean_close = close_roll_mean
average = (high+low)/2
arima_high = high_df[counter]
arima_low = tail(low_df, -n)[counter]
output = data.frame(open=open, high=high, low=low, close=close, average = average, roll_mean = roll_mean_close)
output["high_arima"] = arima_high
output["low_arima"] = arima_low
rownames(output) = rownames(data_list[[1]])
return(output)
}
long_signal = function(data, data_prev, asset = 3) {
open = data[asset, "open"]
close = data[asset, "close"]
average = data[asset, "average"]
open_prev = data_prev[asset, "open"]
close_prev = data_prev[asset, "close"]
average_prev = data_prev[asset, "average"]
close_mean_prev = data_prev[asset, "roll_mean"]
close_mean = data[asset, "roll_mean"]
arima_high = data[asset, "high_arima"]
arima_low = data[asset, "low_arima"]
log.close = log(close)
#is_long_signal = (average_prev > average)
#is_long_signal = (close_mean < close_mean_prev)
is_long_signal = log.close < arima_high
return(list(bar_close=close, is_long_signal=is_long_signal))
}
short_signal = function(data, data_prev, asset = 3) {
open = data[asset, "open"]
close = data[asset, "close"]
average = data[asset, "average"]
open_prev = data_prev[asset, "open"]
close_prev = data_prev[asset, "close"]
average_prev = data_prev[asset, "average"]
close_mean_prev = data_prev[asset, "roll_mean"]
close_mean = data[asset, "roll_mean"]
arima_high = data[asset, "high_arima"]
arima_low = data[asset, "low_arima"]
log.close = log(close)
#is_short_signal = (average_prev < average)
#is_short_signal = (close_mean > close_mean_prev)
is_short_signal = log.close > arima_low
return(list(bar_close=close, is_short_signal=is_short_signal))
}
last_element <- function(x) {
lapply(x, tail, n = 1L)
}
fit_arima_model <- function(return = "high") {
#close = data[asset, "close"]
assets = names(data_format1)
df_high = data.frame(matrix(ncol = nrow(data_format1[['AU.SHF']]), nrow = length(data_format1)))
rownames(df_high) <- names(data_format1)
df_low = data.frame(matrix(ncol = nrow(data_format1[['AU.SHF']]), nrow = length(data_format1)))
rownames(df_high) <- names(data_format1)
for (asset in assets){
asset_data = data_format1[[asset]]
diff.asset_data = data_format1[[asset]]
difflog.asset_data = diff(log(asset_data$close))
log.asset_data = log(asset_data$close)
autoarima = auto.arima(log.asset_data, ic = "aic")
res.autoarima = autoarima$res
arch08=garch(res.autoarima,order=c(0,8),trace=F)
forecast_arima_step1=forecast(autoarima,1,level=95)
forecast_arima=forecast(autoarima,100,level=95)
ht.arch08=arch08$fit[,1]^2
plot(forecast_arima, main='ARIMA Auto,Low,High')
fit212=fitted.values(autoarima)
low=fit212-1.96*sqrt(ht.arch08)
high=fit212+1.96*sqrt(ht.arch08)
plot(log.asset_data,type='l',main='Log Apple,Low,High')
lines(low,col='red')
lines(high,col='blue')
high_df = tapply(high, list(time_index = floor(time(high)), high_price = month.abb[cycle(high)]), c)
low_df = tapply(low, list(time_index = floor(time(high)), high_price = month.abb[cycle(high)]), c)
df_high[asset,] = high_df
df_low[asset,] = low_df
}
if (return == "high") {
return (df_high)
}
if (return == "low") {
return (df_low)
}
}
save(long_signal, short_signal, generate_bar, last_element, file = "functions.RData")
load("functions.RData")
bar_length = 10
asset = 3 # i.e. AU.SHF
my_cash_balance_lower_limit = 3000000
#### Working area 3 ####
# You can set some initial values for memory variable here
memory = list(counter = 0,
long_counter = 0,
short_counter = 0,
data_list = list(),
bar = NULL,
bar_prev = NULL,
long_check_table = data.frame(bar_close=numeric(), is_long_signal=logical()),
short_check_table = data.frame(bar_close=numeric(), is_short_signal=logical())
)
#### Working area 4 ####
# Here is your strategy function
# Note:
# 1. DO NOT modify the function parameters
# 2. The strategy function AWAYS returns a list contains two elements - position and memory. Position is a vector of length 13 (i.e. number of futures in our project); memory is a customer list which will later work as an input parameter when test your strategy at the next minute
strategy = function(time, data, info, initial_cash, transaction, cash_balance, margin_balance, total_balance, position_current, memory=list()){
# Load variables from memory
counter = memory[["counter"]]
long_counter = memory[["long_counter"]]
short_counter = memory[["short_counter"]]
data_list = memory[["data_list"]]
bar = memory[["bar"]]
bar_prev = memory[["bar_prev"]]
long_check_table = memory[["long_check_table"]]
short_check_table = memory[["short_check_table"]]
# Update counter
#counter shows the number of minutes passed
counter = counter + 1
#print(counter)
# Generate OHLC data for every 15 minutes
if(counter%%bar_length == 0){
#print(bar_length)
# save minute data to data_list
data_list[[bar_length]] = data
bar = generate_bar(data_list, counter)
if(!is.null(bar_prev)){
# check patterns for a single bar
long_check = long_signal(data = bar, data_prev = bar_prev, asset = asset)
long_check_table = rbind(long_check_table, long_check)
short_check = short_signal(data = bar, data_prev = bar_prev, asset = asset)
short_check_table = rbind(short_check_table, short_check)
bar_num = counter/bar_length
if(bar_num > 3){
# When there is a three white soider signal, long 10 lots of asset at next minute unless the current cash balance is less than 3,000,000
# if (last_element(long_check_table["is_long_signal"]) == TRUE) && cache_long == 3
if (last_element(long_check_table["is_long_signal"]) == TRUE)  {
print("Long counter")
long_counter = long_counter + 1
if ((cash_balance > my_cash_balance_lower_limit) && (long_counter == 3)) {
position_new[asset] = position_current[asset] + 10
long_counter = 0
#print("Long balance")
#print(position_current)
#print(position_new)
#print(position_old)
}
}
# short signal
# When there is a three black craw signal, short 10 lots of asset at next minute unless the current cash balance is less than 3,000,000
if (last_element(short_check_table["is_short_signal"]) == TRUE) {
print("Short counter")
short_counter = short_counter + 1
print(short_counter)
if((cash_balance > my_cash_balance_lower_limit) && (short_counter == 3)) {
position_new[asset] = position_current[asset] - 10
short_counter = 0
#print("Short balance")
#print(position_current)
#print(position_new)
#print(position_old)
}
}
}
}
bar_prev = bar
} else {
# save minute data to data_list
data_list[[counter%%bar_length]] = data
}
# Update memory
memory[["counter"]] = counter
memory[["data_list"]] = data_list
memory[["bar"]] = bar
memory[["bar_prev"]] = bar_prev
memory[["long_check_table"]] = long_check_table
memory[["short_check_table"]] = short_check_table
memory[["long_counter"]] = long_counter
memory[["short_counter"]] = short_counter
return(list(position=position_new, memory=memory))
#End of the function
}
# begin to test your strategy minute by minute
for(time in time_list){
# 1. initialization
if(time == time_list[[1]]){
cash_balance = initial_cash
total_balance = initial_cash
revenue = 0
margin_balance = 0
average_price_old = rowMeans(data_format2[[time]][1:4])
position_old = rep(0, nrow(info))
position_new = rep(0, nrow(info))
details = data.frame()
stop_signal = FALSE
}
# 2. calculate position & cash/margin/total balance & transaction cost etc.
position_change = position_new - position_old
average_price = rowMeans(data_format2[[time]][1:4])
transaction_cost = sum(abs(position_change)*transaction*average_price*info$unit_per_lot)
margin_change = abs(position_new)*average_price*info$margin_rate*info$unit_per_lot - abs(position_old)*average_price_old*info$margin_rate*info$unit_per_lot
margin_balance = margin_balance + sum(margin_change)
cash_balance = cash_balance - sum(margin_change) - transaction_cost
revenue = sum(position_old*(average_price-average_price_old)*info$unit_per_lot)
total_balance = total_balance + revenue - transaction_cost
details = rbind(details, c(position_new, cash_balance, margin_balance, revenue, total_balance, transaction_cost))
position_old = position_new
average_price_old = average_price
# 3. check special cases
# if cash balance is less than lower limit, clear all futures at next minute and stop strategy (i.e. switch stop_signal to TRUE)
if(cash_balance < cash_balance_lower_limit){
position_new = rep(0, nrow(info))
stop_signal = TRUE
print(paste("Current cash balance is lower than:", as.character(cash_balance_lower_limit)))
print("Your strategy is forced to stop.")
}
# when stop_signal is TRUE, stop the strategy part and keep the current balance (i.e., all cash)
if(stop_signal)
next
# 4. update position for NEXT minute using students' strategy function
output = strategy(time = time,
data = data_format2[[time]],
info = info,
initial_cash = initial_cash,
transaction = transaction,
cash_balance = cash_balance,
margin_balance = margin_balance,
total_balance = total_balance,
position_current = position_new,
memory = memory)
position_new = output[['position']]
memory = output[['memory']]
print(time)
}
colnames(details) = c(as.character(info$code), "cash.balance", "margin.balance", "revenue", "total.balance", "transaction.cost")
rownames(details) = time_list
# show minute-level details about your strategy, including:
# 1. positions of all 13 futures (the first 13 columns)
# 2. cash/margin/total balance
# 3. revenue (profit or loss) at each minute
# 4. transaction cost at each minute
View(details)
# calculate summary statistics (Sharpe ratio, total return, average daily return and maximum dropdown)
balance_xts = xts(x=details$total.balance, order.by=as.POSIXct(time_list))
roc_min = ROC(balance_xts, n = 1, type = "discrete")[2:length(time_list)]
roc_daily = period.apply(roc_min, endpoints(roc_min, "days"), function(x) prod(1+x)-1)
roc_hour = period.apply(roc_min, seq(0, length(time_list)-1, 60), function(x) prod(1+x)-1)
total_ret = prod(1+roc_min)-1
sharpe_ratio = SharpeRatio.annualized(roc_daily)
daily_ret = mean(roc_daily)
max_drawdown = min(DrawdownPeak(roc_hour))
print(paste("Total Return:", as.character(total_ret)))
print(paste("Average Daily Return:", as.character(daily_ret)))
print(paste("Sharpe Ratio:", as.character(sharpe_ratio)))
print(paste("Maximum Drawdown:", as.character(max_drawdown)))
# Draw performance chart (hour-level)
charts.PerformanceSummary(R=roc_hour,
main="Peformance Summary")
